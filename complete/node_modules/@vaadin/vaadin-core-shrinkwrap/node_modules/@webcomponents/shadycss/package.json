{
  "_args": [
    [
      {
        "raw": "@webcomponents/shadycss@https://registry.npmjs.org/@webcomponents/shadycss/-/shadycss-1.9.0.tgz",
        "scope": "@webcomponents",
        "escapedName": "@webcomponents%2fshadycss",
        "name": "@webcomponents/shadycss",
        "rawSpec": "https://registry.npmjs.org/@webcomponents/shadycss/-/shadycss-1.9.0.tgz",
        "spec": "https://registry.npmjs.org/@webcomponents/shadycss/-/shadycss-1.9.0.tgz",
        "type": "remote"
      },
      "C:\\Users\\kazav\\Documents\\GitHub\\gs-crud-with-vaadin\\complete\\node_modules\\@vaadin\\vaadin-core-shrinkwrap"
    ]
  ],
  "_from": "@webcomponents/shadycss@https://registry.npmjs.org/@webcomponents/shadycss/-/shadycss-1.9.0.tgz",
  "_id": "@webcomponents/shadycss@1.9.0",
  "_inCache": true,
  "_location": "/@vaadin/vaadin-core-shrinkwrap/@webcomponents/shadycss",
  "_phantomChildren": {},
  "_requested": {
    "raw": "@webcomponents/shadycss@https://registry.npmjs.org/@webcomponents/shadycss/-/shadycss-1.9.0.tgz",
    "scope": "@webcomponents",
    "escapedName": "@webcomponents%2fshadycss",
    "name": "@webcomponents/shadycss",
    "rawSpec": "https://registry.npmjs.org/@webcomponents/shadycss/-/shadycss-1.9.0.tgz",
    "spec": "https://registry.npmjs.org/@webcomponents/shadycss/-/shadycss-1.9.0.tgz",
    "type": "remote"
  },
  "_requiredBy": [
    "/@vaadin/vaadin-core-shrinkwrap",
    "/@vaadin/vaadin-core-shrinkwrap/@polymer/polymer"
  ],
  "_resolved": "https://registry.npmjs.org/@webcomponents/shadycss/-/shadycss-1.9.0.tgz",
  "_shasum": "8450465037370d4f5c32e801bb2554a7cf2f5037",
  "_shrinkwrap": null,
  "_spec": "@webcomponents/shadycss@https://registry.npmjs.org/@webcomponents/shadycss/-/shadycss-1.9.0.tgz",
  "_where": "C:\\Users\\kazav\\Documents\\GitHub\\gs-crud-with-vaadin\\complete\\node_modules\\@vaadin\\vaadin-core-shrinkwrap",
  "author": {
    "name": "The Polymer Project Authors",
    "url": "https://polymer.github.io/AUTHORS.txt"
  },
  "bugs": {
    "url": "https://github.com/webcomponents/shadycss/issues"
  },
  "dependencies": {},
  "description": "Styling helpers for ShadyDOM",
  "devDependencies": {
    "@webcomponents/custom-elements": "^1.2.1",
    "@webcomponents/html-imports": "^1.2.0",
    "@webcomponents/shadydom": "1.1.2",
    "@webcomponents/template": "^1.4.0",
    "@webcomponents/webcomponents-platform": "^1.0.0",
    "del": "^3.0.0",
    "es6-promise": "^4.2.5",
    "eslint": "^5.7.0",
    "eslint-plugin-html": "^4.0.6",
    "google-closure-compiler": "^20180805.0.0",
    "gulp": "^4.0.0",
    "gulp-rename": "^1.4.0",
    "gulp-size": "^3.0.0",
    "gulp-sourcemaps": "^2.6.4",
    "rollup-stream": "=1.23.1",
    "run-sequence": "^2.2.1",
    "vinyl-buffer": "^1.0.1",
    "vinyl-source-stream": "^2.0.0",
    "wct-browser-legacy": "^1.0.2",
    "web-component-tester": "^6.9.0"
  },
  "directories": {
    "test": "tests"
  },
  "files": [
    "apply-shim.html",
    "apply-shim.min.js*",
    "custom-style-interface.html",
    "custom-style-interface.min.js*",
    "scoping-shim.min.js*",
    "entrypoints/**/*.js",
    "src/**/*.js",
    "externs/**/*.js"
  ],
  "homepage": "https://webcomponents.org/polyfills",
  "keywords": [
    "shady-css",
    "shadycss",
    "shadow-css",
    "shadowcss",
    "web-components",
    "webcomponents",
    "polyfill",
    "shim"
  ],
  "license": "BSD-3-Clause",
  "main": "shadycss.min.js",
  "name": "@webcomponents/shadycss",
  "optionalDependencies": {},
  "publishConfig": {
    "access": "public"
  },
  "readme": "# ShadyCSS\n\nShadyCSS provides a library to simulate ShadowDOM style encapsulation (ScopingShim), a shim for the proposed CSS mixin `@apply` syntax (ApplyShim), and a library to integrate document-level stylesheets with both of the former libraries (CustomStyleInterface).\n\n## Requirements\nShadyCSS requires support for the `<template>` element, ShadowDOM, MutationObserver, Promise, and Object.assign\n\n## Loading\n\nShadyCSS can be used by loading the ScopingShim, ApplyShim, CustomStyleInterface, or any combination of those.\n\nThe most-supported loading order is:\n1. ScopingShim\n1. ApplyShim\n1. CustomStyleInterface\n\nAll libraries will expose an object on `window` named `ShadyCSS` with the following interface:\n\n```js\nShadyCSS = {\n  prepareTemplate(templateElement, elementName, elementExtension){},\n  styleElement(element){},\n  styleSubtree(element, overrideProperties){},\n  styleDocument(overrideProperties){},\n  getComputedStyleValue(element, propertyName){\n    return // style value for property name on element\n  },\n  nativeCss: Boolean,\n  nativeShadow: Boolean\n}\n```\n\n## About ScopingShim\n\nScopingShim provides simulated ShadyDOM style encapsulation, and a shim for CSS Custom Properties.\n\nScopingShim works by rewriting style contents and transforming selectors to enforce scoping.\nAdditionally, if CSS Custom Properties is not detected, ScopingShim will replace CSS Custom Property usage with realized values.\n\n### Example:\nHere's an example of a custom element when Scoping Shim is not needed.\n\n```html\n<my-element>\n  <!-- shadow-root -->\n  <style>\n  :host {\n    display: block;\n  }\n  #container slot::slotted(*) {\n    color: gray;\n  }\n  #foo {\n    color: black;\n  }\n  </style>\n  <div id=\"foo\">Shadow</div>\n  <div id=\"container\">\n    <slot>\n      <!-- span distributed here -->\n    </slot>\n  </div>\n  <!-- /shadow-root -->\n  <span>Light</span>\n</my-element>\n```\n\nbecomes:\n\n```html\n<style scope=\"my-element\">\nmy-element {\n  display: block;\n}\n#container.my-element > * {\n  color: gray;\n}\n#foo.my-element {\n  color: black;\n}\n</style>\n<my-element>\n<div id=\"foo\">Shadow</div>\n<div id=\"container\">\n  <span>Light</span>\n</div>\n</my-element>\n```\n\n## About ApplyShim\n\nApplyShim provides a shim for the `@apply` syntax proposed at https://tabatkins.github.io/specs/css-apply-rule/, which expands the definition CSS Custom Properties to include objects that can be applied as a block.\n\nThis is done by transforming the block definition into a set of CSS Custom Properties, and replacing uses of `@apply` with consumption of those custom properties.\n\n### Status:\n\nThe `@apply` proposal has been abandoned in favor of the ::part/::theme [Shadow Parts spec](https://tabatkins.github.io/specs/css-shadow-parts/). Therefore, the ApplyShim library is deprecated and provided only for backwards compatibility. Support going forward will be limited to critical bug fixes.\n\n### Known Issues:\n\n* Mixin properties cannot be modified at runtime.\n* Nested mixins are not supported.\n* Shorthand properties are not expanded and may conflict with more explicit properties. Whenever shorthand notations are used in conjunction with their expanded forms in `@apply`, depending in the order of usage of the mixins, properties can be overridden. This means that using both `background-color: green;` and `background: red;` in two separate CSS selectors\n can result in `background-color: transparent` in the selector that `background: red;` is specified.\n \n   ```css\n   #nonexistent {\n     --my-mixin: {\n       background: red;\n     }\n   }\n   ```\n   with an element style definition of\n   ```css\n   :host {\n     display: block;\n     background-color: green;\n     @apply(--my-mixin);\n   }\n   ```\n   results in the background being `transparent`, as an empty `background` definition replaces\n   the `@apply` definition. \n \n   For this reason, we recommend avoiding shorthand properties.\n\n### Example:\n\nHere we define a block called `--mixin` at the document level, and apply that block to `my-element` somewhere in the page.\n\n```css\nhtml {\n  --mixin: {\n    border: 2px solid black;\n    background-color: green;\n  }\n}\n\nmy-element {\n  border: 1px dotted orange;\n  @apply --mixin;\n}\n```\n\nbecomes:\n\n```css\nhtml {\n  --mixin_-_border: 2px solid black;\n  --mixin_-_background-color: green;\n}\n\nmy-element {\n  border: var(--mixin_-_border, 1px dotted orange);\n  background-color: var(--mixin_-_background-color);\n}\n```\n\n## About CustomStyleInterface\n\nCustomStyleInterface provides API to process `<style>` elements that are not inside of\nShadowRoots, and simulate upper-boundary style scoping for ShadyDOM.\n\nTo add document-level styles to ShadyCSS, one can call `CustomStyleInterface.addCustomStyle(styleElement)` or `CustomStyleInterface.addCustomStyle({getStyle: () => styleElement})`\n\nAn example usage of the document-level styling api can be found in `examples/document-style-lib.js`, and another example that uses a custom element wrapper can be found in `examples/custom-style-element.js`\n\n### Example:\n\n```html\n<style class=\"document-style\">\nhtml {\n  --content-color: brown;\n}\n</style>\n<my-element>This text will be brown!</my-element>\n<script>\nCustomStyleInterface.addCustomStyle(document.querySelector('style.document-style'));\n</script>\n```\n\nAnother example with a wrapper `<custom-style>` element\n\n```html\n<custom-style>\n  <style>\n  html {\n    --content-color: brown;\n  }\n  </style>\n</custom-style>\n<script>\nclass CustomStyle extends HTMLElement {\n  constructor() {\n    CustomStyleInterface.addCustomStyle(this);\n  }\n  getStyle() {\n    return this.querySelector('style');\n  }\n}\n</script>\n<my-element>This this text will be brown!</my-element>\n```\n\nAnother example with a function that produces style elements\n\n```html\n<my-element>This this text will be brown!</my-element>\n<script>\nCustomStyleInterface.addCustomStyle({\n  getStyle() {\n    const s = document.createElement('style');\n    s.textContent = 'html{ --content-color: brown }';\n    return s;\n  }\n});\n</script>\n```\n\n## Usage\n\nTo use ShadyCSS:\n\n1. First, call `ShadyCSS.prepareTemplate(template, name)` on a\n`<template>` element that will be imported into a `shadowRoot`.\n\n2. When the element instance is connected, call `ShadyCSS.styleElement(element)`\n\n3. Create and stamp the element's shadowRoot\n\n4. Whenever dynamic updates are required, call `ShadyCSS.styleSubtree(element)`.\n\n5. If a styling change is made that may affect the whole document, call\n`ShadyCSS.styleDocument()`.\n\nThe following example uses ShadyCSS and ShadyDOM to define a custom element.\n\n```html\n<template id=\"myElementTemplate\">\n  <style>\n    :host {\n      display: block;\n      padding: 8px;\n    }\n\n    #content {\n      background-color: var(--content-color);\n    }\n\n    .slot-container ::slotted(*) {\n      border: 1px solid steelblue;\n      margin: 4px;\n    }\n  </style>\n  <div id=\"content\">Content</div>\n  <div class=\"slot-container\">\n    <slot></slot>\n  </div>\n</template>\n<script>\n  // Use polyfill only in browsers that lack native Shadow DOM.\n  window.ShadyCSS && ShadyCSS.prepareTemplate(myElementTemplate, 'my-element');\n\n  class MyElement extends HTMLElement {\n    connectedCallback() {\n      window.ShadyCSS && ShadyCSS.styleElement(this);\n      if (!this.shadowRoot) {\n        this.attachShadow({mode: 'open'});\n        this.shadowRoot.appendChild(\n          document.importNode(myElementTemplate.content, true));\n      }\n    }\n  }\n\n  customElements.define('my-element', MyElement);\n</script>\n```\n\n## Type Extension elements\n\nShadyCSS can also be used with type extension elements by supplying the base\nelement name to `prepareTemplate` as a third argument.\n\n### Example\n\n```html\n<template id=\"myElementTemplate\">\n  <style>\n    :host {\n      display: block;\n      padding: 8px;\n    }\n\n    #content {\n      background-color: var(--content-color);\n    }\n\n    .slot-container ::slotted(*) {\n      border: 1px solid steelblue;\n      margin: 4px;\n    }\n  </style>\n  <div id=\"content\">Content</div>\n  <div class=\"slot-container\">\n    <slot></slot>\n  </div>\n</template>\n<script>\n  window.ShadyCSS && ShadyCSS.prepareTemplate(myElementTemplate, 'my-element', 'div');\n\n  class MyElement extends HTMLDivElement {\n    connectedCallback() {\n      window.ShadyCSS && ShadyCSS.styleElement(this);\n      if (!this.shadowRoot) {\n        this.attachShadow({mode: 'open'});\n        this.shadowRoot.appendChild(\n          document.importNode(myElementTemplate.content, true));\n      }\n    }\n  }\n\n  customElements.define('my-element', MyElement, {extends: 'div'});\n</script>\n```\n\n## Imperative values for Custom properties\n\nTo set the value of a CSS Custom Property imperatively, `ShadyCSS.styleSubtree`\nand `ShadyCSS.styleDocument` support an additional argument of an object mapping\nvariable name to value.\n\nWhen using ApplyShim, defining new mixins or new values for current mixins imperatively is not\nsupported.\n\n### Example\n```html\n<my-element id=\"a\">Text</my-element>\n<my-element>Text</my-element>\n<script>\nlet el = document.querySelector('my-element#a');\n// Set the color of all my-element instances to 'green'\nShadyCSS.styleDocument({'--content-color' : 'green'});\n// Set the color my-element#a's text to 'red'\nShadyCSS.styleSubtree(el, {'--content-color' : 'red'});\n</script>\n```\n\n## Limitations\n\n### Selector scoping\n\nTo use the `::slotted` pseudo-element, you must select it as a descendant of some context element.\n```css\n/* Bad */\n::slotted() {}\n\n/* Good */\n.context ::slotted() {}\n```\n\nSince ShadyCSS removes all `<slot>` elements, you cannot select them directly or use any other selectors along with the `::slotted` pseudo-element selector.\n```html\n<!-- Bad -->\n<style>\n  .foo .bar::slotted(*) {}\n</style>\n<span class=\"foo\">\n  <slot class=\"bar\"></slot>\n</span>\n``` \n\n```html\n<!-- Good -->\n<style>\n  .foo ::slotted(*) {}\n</style>\n<span class=\"foo\">\n  <slot></slot>\n</span>\n``` \n\n### Custom properties and `@apply`\n\nDynamic changes are not automatically applied. If elements change such that they\nconditionally match selectors they did not previously, `ShadyCSS.styleDocument()`\nmust be called.\n\nFor a given element's shadowRoot, only 1 value is allowed per custom properties.\nProperties cannot change from parent to child as they can under native custom\nproperties; they can only change when a shadowRoot boundary is crossed.\n\nTo receive a custom property, an element must directly match a selector that\ndefines the property in its host's stylesheet.\n\n### `<custom-style>` Flash of unstyled content\n\nIf `ShadyCSS.applyStyle` is never called, `<custom-style>` elements will process\nafter HTML Imports have loaded, after the document loads, or after the next paint.\nThis means that there may be a flash of unstyled content on the first load.\n\n### Mixins do not cascade throught `<slot>`\n\nCrawling the DOM and updating styles is very expensive, and we found that trying to\nupdate mixins through `<slot>` insertion points to be too expensive to justify for both\npolyfilled CSS Mixins and polyfilled CSS Custom Properties.\n\n### External stylesheets not currently supported\n\nExternal stylesheets loaded via `<link rel=\"stylesheet\">` within a shadow root or\n`@import` syntax inside a shadow root's stylesheet are not currently shimmed by\nthe polyfill.  This is mainly due to the fact that shimming them would require\na fetch of the stylesheet text that is async cannot be easily coordinated with\nthe upgrade timing of custom elements using them, making it impossible to avoid\n\"flash of unstyled content\" when running on polyfill.\n\n### Document level styling is not scoped by default\n\nShadyCSS mimics the behavior of shadow dom, but it is not able to prevent document\nlevel styling to affect elements inside a shady dom. Global styles defined in\n`index.html` or any styles not processed by ShadyCSS will affect all elements on the page.\n\nTo scope document level styling, the style must be wrapped in the `<custom-style>` element\nfound in Polymer, or use the `CustomStyleInterface` library to modify document level styles.\n\n### Dynamically created styles are not supported\n\nShadyCSS works by processing a template for a given custom element class. Only the style\nelements present in that template will be scoped for the custom element's ShadowRoot.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/webcomponents/shadycss.git"
  },
  "scripts": {
    "build": "gulp",
    "debug": "gulp debug",
    "lint": "eslint src tests entrypoints",
    "prepack": "gulp closure",
    "test": "npm run lint && gulp && wct"
  },
  "version": "1.9.0"
}
